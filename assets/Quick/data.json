{
	"algorithm": "int partition(List list, int low, int high) {\n\t\t\tint pivot = list[high];\n\t\t\tint i = low - 1;\n\t\t\tfor (int j = low; j < high; j++) {\n\t\t\t\t\t\tif (list[j] <= pivot) {\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\tswap(list, i, j);\n\t\t\t\t\t\t}\n\t\t\tswap(list, i+1, high);\n\t\t\treturn i+1;\n}\n\nvoid swap(List list, int i, int j) {\n\t\t\tint temp = list[i];\n\t\t\tlist[i] = list[j];\n\t\t\tlist[j] = temp;\n}\n\nvoid quickSort(List list, int low, int high) {\n\t\t\tif (low < high) {\n\t\t\t\t\t\tint pi = partition(list, low, high);\n\t\t\t\t\t\tquickSort(list, low, pi-1);\n\t\t\t\t\t\tquickSort(list, pi+1, high);\n\t\t\t}\n}",
	"discussion": [
		"При аккуратной реализации быстрая сортировка является надежной и имеет низкие накладные расходы. Когда стабильная сортировка не требуется, быстрая сортировка является отличной сортировкой общего назначения - хотя вместо этого всегда следует использовать версию с 3-сторонним разделением.",
		"Код двухстороннего разделения, показанный выше, написан для ясности, а не оптимальной производительности; он имеет плохую локальность и, что важно, показывает время O(n2), когда уникальных ключей мало. Роберт Седжвик и Джон Бентли предложили более эффективный и надежный метод двухстороннего разделения. Надежное разбиение создает сбалансированную рекурсию, когда существует много значений, равных центральной точке, что дает вероятностные гарантии времени O(n * lg(n)) и пространства O(lg(n)) для всех входов.",
		"При выполнении рекурсивного выполнения обоих под-сортировок быстрая сортировка требует O(n) дополнительного пространства для стека рекурсии в худшем случае, когда рекурсия не сбалансирована. Это крайне маловероятно, но этого можно избежать, сначала рекурсивно сортируя меньший подмассив; вторая сортировка подмассива - это хвостовой рекурсивный вызов, который можно сделать с помощью итерации. С этой оптимизацией алгоритм использует O(lg(n)) дополнительное пространство в худшем случае."
	],
	"properties": [
		"Нестабильный",
		"O(lg(n)) дополнительного пространства (см. Обсуждение)",
		"Время O(n2), но обычно время O(n * lg(n))",
		"Не адаптивный"
	],
	"efficiency": 4.5,
	"animate_targets": {
		"random": 93,
		"nearly_sorted": 94,
		"reversed": 93,
		"few_unique": 148
	}
}