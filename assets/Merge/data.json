{
	"algorithm": "void mergeSort(List<int> list) {\n\t\t\tmergeSortRange(list, 0, list.length - 1);\n}\n\nvoid mergeSortRange(List<int> list, int l, int r) {\n\t\t\tif (l >= r) return;\n\t\t\tint m = l + (r - l) ~/ 2;\n\t\t\tmergeSortRange(list, l, m);\n\t\t\tmergeSortRange(list, m + 1, r);\n\t\t\tmerge(list, l, m, r);\n}\n\nvoid merge(List<int> list, int l, int m, int r) {\n\t\t\tList<int> res = list.sublist(l, r + 1);\n\t\t\tint i1 = l;\n\t\t\tint i2 = m + 1;\n\t\t\tint i = l;\n\t\t\twhile (i1 <= m && i2 <= r) {\n\t\t\t\t\t\tint v1 = res[i1 - l];\n\t\t\t\t\t\tint v2 = res[i2 - l];\n\t\t\t\t\t\tif (v1 < v2) {\n\t\t\t\t\t\t\t\t\tlist[i++] = v1;\n\t\t\t\t\t\t\t\t\t++i1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlist[i++] = v2;\n\t\t\t\t\t\t\t\t\t++i2;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t\twhile (i1 <= m) list[i++] = res[i1++ - l];\n\t\t\twhile (i2 <= m) list[i++] = res[i2++ - l];\n}",
	"discussion": [
		"Слияние сортировок очень предсказуемо. Это делает между 0,5lg(n) и lg(n) сравнениями на элемент, и между lg(n) и 1.5lg(n) перестановками на элемент. Минимумы достигнуты для уже отсортированных данных; максимумы достигаются в среднем для случайных данных. Если использование Θ(n) лишнего пространства не имеет значения, тогда сортировка по слиянию - отличный выбор: он прост в реализации и является единственным стабильным алгоритмом сортировки O(n * lg(n)). Обратите внимание, что при сортировке связанных списков сортировка слиянием требует только Θ(lg(n)) дополнительного пространства (для рекурсии).",
		"Сортировка слиянием является предпочтительным алгоритмом для множества ситуаций: когда требуется стабильность, когда сортировка связанных списков и когда произвольный доступ намного дороже, чем последовательный доступ (например, внешняя сортировка на ленте).",
		"Существуют линейные алгоритмы слияния на месте для последнего шага алгоритма, но они дорогие и сложные. Сложность оправдана для таких приложений, как внешняя сортировка, когда Θ(n) лишнего пространства не доступно."
	],
	"properties": [
		"Стабильный",
		"Θ(n) дополнительного пространства для массивов (как показано)",
		"Θ(lg(n)) дополнительного места для связанных списков",
		"Θ(n * lg(n)) время",
		"Не адаптивный",
		"Не требует произвольного доступа к данным"
	],
	"efficiency": 4.5,
	"animate_targets": {
		"random": 89,
		"nearly_sorted": 89,
		"reversed": 89,
		"few_unique": 89
	}
}